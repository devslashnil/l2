package pattern

/*
	Реализовать паттерн «цепочка вызовов».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
*/

/*
	Применимость:
	- Необходимость обработки запроса более чем одним обработчиком (хэндлером)

	Плюсы:
	- Каждый обработчик отвечает за свою зону ответственности, что позволяет
	достигнуть принципа единственной ответственности
	- Легко переиспользовать обработчики, составляя новые цепочки

	Минусы:
	- Контроль над обработкой полностью лежит на обработчиках, и в случае
	изменения логики может потребовать изменения во всех обработчиках сразу
	- Нельзя манипулировать данными на вход обработчика, как все ожидают
	одной и той же структуры сообщения

	Реальные примеры:
	- Создание middleware структур
	- Для распространения некоторого запроса или ивента по многим частям системы
*/

// Handler интерфейс хэндлера
type Handler interface {
	Handle(msg int) int
}

// Receiver1 имплементация хэндлера
type Receiver1 struct {
	next Handler
}

// Handle обработчик Receiver1
func (r *Receiver1) Handle(msg int) (res int) {
	if msg == 1 {
		res = 1
	} else if r.next != nil {
		res = r.next.Handle(msg)
	}
	return
}

// Receiver2 имплементация хэндлера
type Receiver2 struct {
	next Handler
}

// Handle обработчик Receiver2
func (r *Receiver2) Handle(msg int) (res int) {
	if msg == 2 {
		res = 2
	} else if r.next != nil {
		res = r.next.Handle(msg)
	}
	return
}
